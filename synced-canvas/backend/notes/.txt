m ne almost sara kam kr lia h ab bus ye below kam rehta h
4. The Presence Flow (Awareness)
â— Heartbeat: The app constantly shares the $(x, y)$ coordinates of every active user's
cursor.
â— Visual Cues: Remote cursors are rendered as "ghost icons" with name tags, providing
the feeling of a shared physical space

ye m kis trhn hota h aur ye m kese kr sakta hun mera backend asa h

------------------- backend ----------------

canvasSocket.js

import Room from "../models/Room.js";
import Stroke from "../models/Stroke.js";

export default function canvasSocket(io) {
  io.on("connection", (socket) => {
    console.log("User connected:", socket.id, "name:", socket.user?.username);

    // ---------------------------
    // Join Room + Send History
    // ---------------------------
    socket.on("joinRoom", async ({ roomId }) => {
      try {
        if (!socket.user) {
          return socket.emit("error", "Not authenticated");
        }

        const userId = socket.user._id;

        // Find room WITHOUT populate first
        let room = await Room.findById(roomId);

        if (!room) {
          return socket.emit("error", "Room not found");
        }

        // Check if already member
        const isMember = room.members.some(
          (memberId) => memberId.toString() === userId.toString(),
        );

        // Add only if not exists
        if (!isMember) {
          room.members.push(userId);
          await room.save();
        }

        // IMPORTANT: Populate AFTER update
        room = await Room.findById(roomId)
          .populate("members", "username email")
          .populate("createdBy", "username email");

        socket.join(roomId);

        // Notify others (only new join)
        io.to(roomId).emit("roomMembers", room.members);

        // Send room info WITH populated members
        socket.emit("roomInfo", {
          id: room._id,
          name: room.name,
          createdBy: room.createdBy,
        });

        // Send strokes history
        const strokes = await Stroke.find({
          roomId,
          isDeleted: false,
        });

        socket.emit("roomHistory", strokes);
      } catch (err) {
        console.error("joinRoom error:", err.message);
        socket.emit("error", "Something went wrong joining room");
      }
    });

    // ---------------------------
    // Leave Room
    // ---------------------------
    socket.on("leaveRoom", async (roomId) => {
      const userId = socket.user._id;
      let room = await Room.findById(roomId);

      if (!room) {
        return socket.emit("error", "Room not found");
      }
      // Remove member
      room.members = room.members.filter(
        (member) => member.toString() !== userId.toString(),
      );
      await room.save();

      // IMPORTANT: Populate AFTER update
      room = await Room.findById(roomId).populate("members", "username email");

      socket.leave(roomId);
      io.to(roomId).emit("roomMembers", room.members);
    });

    // ---------------------------
    // Stroke Start (Emit to others in room)
    // ---------------------------
    socket.on("strokeStart", ({ roomId, strokeId, point }) => {
      try {
        if (!socket.user) {
          return socket.emit("error", "Not authenticated");
        }
        // Emit to others in room
        socket.to(roomId).emit("strokeStart", {
          userId: socket.user._id.toString(),
          strokeId,
          point,
        });
      } catch (err) {
        // console.error("strokeStart error:", err.message);
        socket.emit("error", "Failed to start stroke");
      }
    });

    //----------------------------
    // Stroke Point (Emit to others in room)
    //----------------------------
    socket.on(
      "strokePoint",
      ({ roomId,strokeId, color, brushSize, point }) => {
        try {
          if (!socket.user) {
            return socket.emit("error", "Not authenticated");
          }
          // console.log(
          //   "ðŸŽ¨ strokePoint received ",
          //   "userId:",
          //   socket.user._id.toString(),
          //   "strokeId:",
          //   strokeId,
          //   "color:",
          //   color,
          //   "brushSize:",
          //   brushSize,
          //   "point:",
          //   point,
          // );
          socket.to(roomId).emit("strokePoint", {
            userId: socket.user._id.toString(),
            strokeId,
            color,
            brushSize,
            point,
          });
        } catch (err) {
          console.error("strokePoint error:", err.message);
          socket.emit("error", "Failed to record stroke point");
        }
      },
    );

    //----------------------------
    // Stroke End (Save to DB and Emit to others in room)
    //----------------------------
    socket.on(
      "strokeEnd",
      async ({ roomId, strokeId, color, brushSize,points }) => {
        try {
          if (!socket.user) {
            return socket.emit("error", "Not authenticated");
          }
          const newStroke = await Stroke.create({
            strokeId, // frontend strokeId
            roomId,
            userId: socket.user._id,
            color,
            width: brushSize,
            points
          });

          // console.log("ðŸŽ¨ New stroke created:", newStroke);

          // Emit strokeComplete with DB _id + strokeId to ALL users in room (including sender)
          io.to(roomId).emit("strokeComplete", {
            ...newStroke.toObject(),
            strokeId: newStroke.strokeId, // frontend strokeId for matching
          });
        } catch (err) {
          console.error("strokeEnd error:", err.message);
          socket.emit("error", "Failed to save stroke");
        }
      },
    );
 
    // ---------------------------
    // Undo (Soft Delete)
    // ---------------------------
    socket.on("undo", async ({ roomId, strokeId }) => {
      try {
        if (!socket.user) {
          return socket.emit("error", "Not authenticated");
        }

        if (!strokeId) {
          return socket.emit("error", "No strokeId provided");
        }

        const stroke = await Stroke.findOne({
          strokeId,
          userId: socket.user._id,
        });

        if (!stroke) {
          return socket.emit("error", "Stroke not found or not yours");
        }

        stroke.isDeleted = true;
        await stroke.save();

        console.log(`â†¶ Undo for strokeId:`, strokeId);
        io.to(roomId).emit("undo", { strokeId });
      } catch (err) {
        console.error("undo error:", err.message);
        socket.emit("error", "Unable to undo stroke");
      }
    });

    // ---------------------------
    // Redo (Restore Last Deleted Stroke of User)
    // ---------------------------
    socket.on("redo", async ({ roomId, strokeId }) => {
      try {
        if (!socket.user) {
          return socket.emit("error", "Not authenticated");
        }

        let stroke;

        // If strokeId is provided, redo that specific stroke
        if (strokeId) {
          stroke = await Stroke.findOne({
            strokeId,
            userId: socket.user._id,
            isDeleted: true,
          });
        } else {
          // Otherwise, redo the last deleted stroke (currently ignore this)
          stroke = await Stroke.findOne({
            roomId,
            userId: socket.user._id,
            isDeleted: true,
          }).sort({ updatedAt: -1 });
        }

        if (!stroke) return socket.emit("error", "No stroke to redo");

        stroke.isDeleted = false;
        await stroke.save();

        io.to(roomId).emit("redoStroke", {
          ...stroke.toObject(),
          strokeId: stroke.strokeId,
        });

        console.log(`â†» Redo for strokeId:`, stroke.strokeId);
      } catch (err) {
        console.error("redo error:", err.message);
        socket.emit("error", "Unable to redo stroke");
      }
    });

    // ---------------------------
    // Clear (Soft Delete All)
    // ---------------------------
    socket.on("clear", async ({ roomId }) => {
      try {
        await Stroke.updateMany({ roomId }, { isDeleted: true });
        io.to(roomId).emit("clear");
      } catch (err) {
        socket.emit("error", "Unable to clear strokes");
      }
    });
    // ---------------------------
    // Disconnect
    // ---------------------------
    socket.on("disconnect", async () => {
      console.log("âœ— User disconnected:", socket.id);
      if (!socket.user) return;

      const userId = socket.user._id;

      // Find all rooms user was in
      const rooms = await Room.find({ members: userId });

      for (let room of rooms) {
        // Remove user from members (user at a time aik hi room m hoga, but phir bhi ye safety k lien)
        room.members = room.members.filter(
          (member) => member.toString() !== userId.toString(),
        );
        await room.save();

        // Populate members after update
        const updatedRoom = await Room.findById(room._id).populate(
          "members",
          "username email",
        );

        // Notify other users in that room
        io.to(room._id.toString()).emit("roomMembers", updatedRoom.members);
      }

      console.log("  User was:", socket.user.username, `(${userId})`);
    });
  });
}



---------------------- frontend ---------------------------

canvasUtils.js

import { useCanvasStore } from "../store/canvasStore";
import { socket } from "../socket/socket";

// ===============================
// find the last stroke ID of a user (used for undo functionality)
// ===============================
export const findLastUserStrokeId = (strokes, userId) => {
  const reversed = [...strokes].reverse();
  const lastStroke = reversed.find((stroke) => stroke.userId === userId);
  return lastStroke ? lastStroke.strokeId : null;
};

// ===============================
// undo the last stroke of the current user
// ===============================
export const undoLastStroke = (strokes, undo, currentRoomId) => {
  const store = useCanvasStore.getState();
  const userId = store.user.id;
  const lastStrokeId = findLastUserStrokeId(strokes, userId);
  if (!lastStrokeId) return;

  undo(lastStrokeId);

  socket.emit("undo", {
    roomId: currentRoomId,
    strokeId: lastStrokeId,
  });
};

// ===============================
// redo the last undo stroke of the current user
// ===============================
export const redoLastStroke = (redo, currentRoomId) => {
  const store = useCanvasStore.getState();
  const undoStack = store.undoStack;
  const userId = store.user.id;

  // view this in future after refreash user can not redo
  if (undoStack.length === 0) {
    console.warn("âš  Nothing to redo");
    return;
  }

  const reversed = [...undoStack].reverse();

  // find last undone stroke of this user  const reversed = [...undoStack].reverse();
  const lastUndoneStroke = reversed.find((stroke) => stroke.userId === userId);
  if (!lastUndoneStroke) {
    console.warn("âš  No undone stroke found for this user");
    return;
  }

  redo(lastUndoneStroke);
  // console.log("â†» Redoing stroke:", lastUndoneStroke.strokeId);

  socket.emit("redo", {
    roomId: currentRoomId,
    strokeId: lastUndoneStroke.strokeId,
  });
};

// ===============================
// ROOM JOINING
// ===============================
export const joinRoom = (roomId, currentRoomId, clear) => {
  if (!roomId.trim()) return;

  if (currentRoomId && currentRoomId !== roomId) {
    socket.emit("leaveRoom", currentRoomId);
  }

  console.log("ðŸ“ Joining room:", roomId);
  socket.emit("joinRoom", { roomId });

  clear();
};

// ===============================
// START DRAW
// ===============================
export const startDrawing = (
  e,
  setIsDrawing,
  startStroke,
  canvasRef,
  currentRoomId,
) => {
  const store = useCanvasStore.getState();
  const userId = store.user.id;

  if (!userId) {
    // console.log("Cannot start stroke - userId not found");
    return;
  }

  const x = e.nativeEvent.offsetX;
  const y = e.nativeEvent.offsetY;
  const strokeId = crypto.randomUUID();
  setIsDrawing(true);
  startStroke({
    userId,
    strokeId,
    point: { x, y },
  });

  const ctx = canvasRef.current.getContext("2d");
  ctx.beginPath();
  ctx.moveTo(x, y);

  // console.log(
  //   "ðŸŽ¨ strokeStart sent for room:",
  //   currentRoomId,
  //   "strokeId:",
  //   strokeId,
  // );
  socket.emit("strokeStart", {
    roomId: currentRoomId,
    strokeId,
    point: { x, y },
  });

  // console.log(
  //   "ðŸŽ¨ strokeStart emitted",
  //   "userId:",
  //   userId,
  //   "strokeId:",
  //   strokeId,
  //   "point:",
  //   { x, y },
  // );
};

// ===============================
// DRAW (RAF THROTTLED)
// ===============================
export const draw = (
  e,
  isDrawing,
  animationFrameRef,
  lastPointRef,
  color,
  brushSize,
  addPoint,
  canvasRef,
  currentRoomId,
) => {
  if (!isDrawing) return;

  const store = useCanvasStore.getState();
  const userId = store.user.id;
  const strokeId = store.currentStrokes[userId]?.strokeId;

  // console.log("store.currentStrokes[userId]", store.currentStrokes[userId]);
  // console.log(
  //   "store.currentStrokes[userId]?.strokeId",
  //   store.currentStrokes[userId]?.strokeId,
  // );

  if (!userId) {
    console.log("Cannot add point - userId not found");
    return;
  }

  const x = e.nativeEvent.offsetX;
  const y = e.nativeEvent.offsetY;

  lastPointRef.current = { x, y };

  if (animationFrameRef.current) return;

  animationFrameRef.current = requestAnimationFrame(() => {
    const point = lastPointRef.current;
    const ctx = canvasRef.current.getContext("2d");

    ctx.strokeStyle = color;
    ctx.lineWidth = brushSize;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    ctx.lineTo(point.x, point.y);
    ctx.stroke();

    addPoint({ userId, strokeId, point });

    socket.emit("strokePoint", {
      roomId: currentRoomId,
      strokeId,
      color,
      brushSize,
      point,
    });

    // console.log(
    //   "ðŸŽ¨ strokePoint emitted",
    //   "userId:",
    //   userId,
    //   "strokeId:",
    //   strokeId,
    //   "point:",
    //   point,
    // );

    animationFrameRef.current = null;
  });
};

// ===============================
// STOP DRAW
// ===============================
export const stopDrawing = (
  setIsDrawing,
  endStroke,
  color,
  brushSize,
  currentRoomId,
) => {
  setIsDrawing(false);

  // Get the current stroke data from the store
  const store = useCanvasStore.getState();
  const userId = store.user.id;
  const currentStroke = store.currentStrokes[userId];

  if (currentStroke) {
    const { strokeId, points } = currentStroke;

    endStroke({ userId, strokeId, color, brushSize, points });

    socket.emit("strokeEnd", {
      roomId: currentRoomId,
      strokeId,
      color,
      brushSize,
      points,
    });

    // console.log(
    //   "ðŸŽ¨ strokeEnd emitted",
     
    //   "strokeId:",
    //   strokeId,
    //   "color:",
    //   color,
    //   "brushSize:",
    //   brushSize,
    //   "points:",
    //   points,
    //   );
  }
};

// ===============================
// REDRAW FUNCTION
// ===============================
export const redrawCanvas = (canvasRef) => {
  const store = useCanvasStore.getState();
  const strokes = store.strokes;

  if (!canvasRef.current) return;

  const canvas = canvasRef.current;
  const ctx = canvas.getContext("2d");

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!strokes || !Array.isArray(strokes)) return;

  strokes.forEach((stroke) => {
    // Skip strokes without points
    if (!stroke || !stroke.points || !Array.isArray(stroke.points)) {
      console.warn("Skipping invalid stroke:", stroke);
      return;
    }

    ctx.beginPath();
    ctx.strokeStyle = stroke.color || "#ffffff";
    ctx.lineWidth = stroke.brushSize || stroke.width || 5;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    stroke.points.forEach((point, index) => {
      if (index === 0) ctx.moveTo(point.x, point.y);
      else ctx.lineTo(point.x, point.y);
    });

    ctx.stroke();
  });
};



canvasStore.js 

import { useCanvasStore } from "../store/canvasStore";
import { socket } from "../socket/socket";

// ===============================
// find the last stroke ID of a user (used for undo functionality)
// ===============================
export const findLastUserStrokeId = (strokes, userId) => {
  const reversed = [...strokes].reverse();
  const lastStroke = reversed.find((stroke) => stroke.userId === userId);
  return lastStroke ? lastStroke.strokeId : null;
};

// ===============================
// undo the last stroke of the current user
// ===============================
export const undoLastStroke = (strokes, undo, currentRoomId) => {
  const store = useCanvasStore.getState();
  const userId = store.user.id;
  const lastStrokeId = findLastUserStrokeId(strokes, userId);
  if (!lastStrokeId) return;

  undo(lastStrokeId);

  socket.emit("undo", {
    roomId: currentRoomId,
    strokeId: lastStrokeId,
  });
};

// ===============================
// redo the last undo stroke of the current user
// ===============================
export const redoLastStroke = (redo, currentRoomId) => {
  const store = useCanvasStore.getState();
  const undoStack = store.undoStack;
  const userId = store.user.id;

  // view this in future after refreash user can not redo
  if (undoStack.length === 0) {
    console.warn("âš  Nothing to redo");
    return;
  }

  const reversed = [...undoStack].reverse();

  // find last undone stroke of this user  const reversed = [...undoStack].reverse();
  const lastUndoneStroke = reversed.find((stroke) => stroke.userId === userId);
  if (!lastUndoneStroke) {
    console.warn("âš  No undone stroke found for this user");
    return;
  }

  redo(lastUndoneStroke);
  // console.log("â†» Redoing stroke:", lastUndoneStroke.strokeId);

  socket.emit("redo", {
    roomId: currentRoomId,
    strokeId: lastUndoneStroke.strokeId,
  });
};

// ===============================
// ROOM JOINING
// ===============================
export const joinRoom = (roomId, currentRoomId, clear) => {
  if (!roomId.trim()) return;

  if (currentRoomId && currentRoomId !== roomId) {
    socket.emit("leaveRoom", currentRoomId);
  }

  console.log("ðŸ“ Joining room:", roomId);
  socket.emit("joinRoom", { roomId });

  clear();
};

// ===============================
// START DRAW
// ===============================
export const startDrawing = (
  e,
  setIsDrawing,
  startStroke,
  canvasRef,
  currentRoomId,
) => {
  const store = useCanvasStore.getState();
  const userId = store.user.id;

  if (!userId) {
    // console.log("Cannot start stroke - userId not found");
    return;
  }

  const x = e.nativeEvent.offsetX;
  const y = e.nativeEvent.offsetY;
  const strokeId = crypto.randomUUID();
  setIsDrawing(true);
  startStroke({
    userId,
    strokeId,
    point: { x, y },
  });

  const ctx = canvasRef.current.getContext("2d");
  ctx.beginPath();
  ctx.moveTo(x, y);

  // console.log(
  //   "ðŸŽ¨ strokeStart sent for room:",
  //   currentRoomId,
  //   "strokeId:",
  //   strokeId,
  // );
  socket.emit("strokeStart", {
    roomId: currentRoomId,
    strokeId,
    point: { x, y },
  });

  // console.log(
  //   "ðŸŽ¨ strokeStart emitted",
  //   "userId:",
  //   userId,
  //   "strokeId:",
  //   strokeId,
  //   "point:",
  //   { x, y },
  // );
};

// ===============================
// DRAW (RAF THROTTLED)
// ===============================
export const draw = (
  e,
  isDrawing,
  animationFrameRef,
  lastPointRef,
  color,
  brushSize,
  addPoint,
  canvasRef,
  currentRoomId,
) => {
  if (!isDrawing) return;

  const store = useCanvasStore.getState();
  const userId = store.user.id;
  const strokeId = store.currentStrokes[userId]?.strokeId;

  // console.log("store.currentStrokes[userId]", store.currentStrokes[userId]);
  // console.log(
  //   "store.currentStrokes[userId]?.strokeId",
  //   store.currentStrokes[userId]?.strokeId,
  // );

  if (!userId) {
    console.log("Cannot add point - userId not found");
    return;
  }

  const x = e.nativeEvent.offsetX;
  const y = e.nativeEvent.offsetY;

  lastPointRef.current = { x, y };

  if (animationFrameRef.current) return;

  animationFrameRef.current = requestAnimationFrame(() => {
    const point = lastPointRef.current;
    const ctx = canvasRef.current.getContext("2d");

    ctx.strokeStyle = color;
    ctx.lineWidth = brushSize;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    ctx.lineTo(point.x, point.y);
    ctx.stroke();

    addPoint({ userId, strokeId, point });

    socket.emit("strokePoint", {
      roomId: currentRoomId,
      strokeId,
      color,
      brushSize,
      point,
    });

    // console.log(
    //   "ðŸŽ¨ strokePoint emitted",
    //   "userId:",
    //   userId,
    //   "strokeId:",
    //   strokeId,
    //   "point:",
    //   point,
    // );

    animationFrameRef.current = null;
  });
};

// ===============================
// STOP DRAW
// ===============================
export const stopDrawing = (
  setIsDrawing,
  endStroke,
  color,
  brushSize,
  currentRoomId,
) => {
  setIsDrawing(false);

  // Get the current stroke data from the store
  const store = useCanvasStore.getState();
  const userId = store.user.id;
  const currentStroke = store.currentStrokes[userId];

  if (currentStroke) {
    const { strokeId, points } = currentStroke;

    endStroke({ userId, strokeId, color, brushSize, points });

    socket.emit("strokeEnd", {
      roomId: currentRoomId,
      strokeId,
      color,
      brushSize,
      points,
    });

    // console.log(
    //   "ðŸŽ¨ strokeEnd emitted",
     
    //   "strokeId:",
    //   strokeId,
    //   "color:",
    //   color,
    //   "brushSize:",
    //   brushSize,
    //   "points:",
    //   points,
    //   );
  }
};

// ===============================
// REDRAW FUNCTION
// ===============================
export const redrawCanvas = (canvasRef) => {
  const store = useCanvasStore.getState();
  const strokes = store.strokes;

  if (!canvasRef.current) return;

  const canvas = canvasRef.current;
  const ctx = canvas.getContext("2d");

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!strokes || !Array.isArray(strokes)) return;

  strokes.forEach((stroke) => {
    // Skip strokes without points
    if (!stroke || !stroke.points || !Array.isArray(stroke.points)) {
      console.warn("Skipping invalid stroke:", stroke);
      return;
    }

    ctx.beginPath();
    ctx.strokeStyle = stroke.color || "#ffffff";
    ctx.lineWidth = stroke.brushSize || stroke.width || 5;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    stroke.points.forEach((point, index) => {
      if (index === 0) ctx.moveTo(point.x, point.y);
      else ctx.lineTo(point.x, point.y);
    });

    ctx.stroke();
  });
};


aur is trhn mere canvasRoom ki file h jhn ye functions call hoty hn