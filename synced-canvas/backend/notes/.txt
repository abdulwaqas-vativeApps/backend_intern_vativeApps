mera ab current code is trhn ka ho gia h 

++++++++++++++++++++ frontend ++++++++++++++++++++++
import { useRef, useEffect, useState, use } from "react";
import { useCanvasStore } from "../store/canvasStore";
import { socket } from "../socket/socket";
import { undoLastStroke, redoLastStroke, joinRoom, startDrawing, draw, stopDrawing, redrawCanvas } from "../utils/canvasUtils";

export default function CanvasBoard() {
  const canvasRef = useRef(null);
  const animationFrameRef = useRef(null);
  const lastPointRef = useRef(null);

  const strokes = useCanvasStore((state) => state.strokes);
  const startStroke = useCanvasStore((state) => state.startStroke);
  const addPoint = useCanvasStore((state) => state.addPoint);
  const endStroke = useCanvasStore((state) => state.endStroke);
  const undo = useCanvasStore((state) => state.undo);
  const redo = useCanvasStore((state) => state.redo);
  const clear = useCanvasStore((state) => state.clear);

  const [isDrawing, setIsDrawing] = useState(false);
  const [color, setColor] = useState("#ffffff");
  const [brushSize, setBrushSize] = useState(5);
  const [roomId, setRoomId] = useState("");
  const [currentRoom, setCurrentRoom] = useState(null);

  // console.log("CanvasBoard Rendered with strokes:", strokes);

  // ===============================
  // SOCKET SETUP
  // ===============================
  useEffect(() => {
    socket.on("strokeStart", ({ userId, strokeId, point }) => {
      startStroke({ userId, strokeId, point });

      const ctx = canvasRef.current.getContext("2d");
      ctx.beginPath();
      ctx.moveTo(point.x, point.y);
    });

    socket.on("strokePoint", ({ userId, point, color, brushSize }) => {
      const store = useCanvasStore.getState();

      // check stroke exists
      if (!store.currentStrokes[userId]) {
        console.warn("Received strokePoint before strokeStart");
        return;
      }

      const ctx = canvasRef.current.getContext("2d");

      ctx.strokeStyle = color;
      ctx.lineWidth = brushSize;

      ctx.lineTo(point.x, point.y);
      ctx.stroke();

      addPoint({ userId, point });
    });

    socket.on("strokeEnd", ({ userId, color, brushSize }) => {
      endStroke({ userId, color, brushSize });
    });

    socket.on("undo", ({ strokeId }) => {
      undo(strokeId);
    });

    socket.on("redo", ({ userId }) => {
      console.log("Redoing stroke by ON:", userId);
      redo(userId);
    });

    socket.on("clear", () => {
      clear();
    });

    return () => {
      socket.off("strokeStart");
      socket.off("strokePoint");
      socket.off("strokeEnd");
      socket.off("undo");
      socket.off("redo");
      socket.off("clear");
    };
  }, []);

  // ===============================
  // CANVAS INIT
  // ===============================
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");

    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, []);

  useEffect(() => {
    redrawCanvas(canvasRef);
  }, [strokes]);

  const handleJoinRoom = () => {
    joinRoom(roomId, currentRoom, clear);
    setCurrentRoom(roomId);
  };

  return (
    <div style={{ padding: "20px" }}>
      <h2>Zustand Synced Canvas</h2>

      <div style={{ marginBottom: "10px" }}>
        <div style={{ marginBottom: "10px" }}>
          <input
            type="text"
            placeholder="Enter Room ID"
            value={roomId}
            onChange={(e) => setRoomId(e.target.value)}
          />
          <button onClick={handleJoinRoom}>Join Room</button>
        </div>

        {currentRoom && <p>Current Room: {currentRoom}</p>}
        <input
          type="color"
          value={color}
          onChange={(e) => setColor(e.target.value)}
        />
        <input
          type="range"
          min="1"
          max="20"
          value={brushSize}
          onChange={(e) => setBrushSize(e.target.value)}
        />
        <button onClick={() => undoLastStroke(strokes, undo, currentRoom)}>Undo</button>
        <button onClick={() => redoLastStroke(redo, currentRoom)}>Redo</button>

        <button
          onClick={() => {
            clear();
            socket.emit("clear", { roomId: currentRoom });
          }}
        >
          Clear
        </button>
      </div>

      <canvas
        ref={canvasRef}
        width={900}
        height={500}
        style={{ border: "2px solid black", background: "black" }}
        onMouseDown={(e) => startDrawing(e, setIsDrawing, startStroke, canvasRef, currentRoom)}
        onMouseMove={(e) => draw(e, isDrawing, animationFrameRef, lastPointRef, color, brushSize, addPoint, canvasRef, currentRoom)}
        onMouseUp={() => stopDrawing(setIsDrawing, endStroke, color, brushSize, currentRoom)}
        onMouseLeave={() => stopDrawing(setIsDrawing, endStroke, color, brushSize, currentRoom)}
      />
    </div>
  );
}













import { create } from "zustand";

export const useCanvasStore = create((set) => ({
  strokes: [],
  currentStrokes: {},
  redoStack: [],

  // ==================================
  // start a new stroke for a user with the initial point
  // ==================================
  startStroke: ({ userId, strokeId, point }) =>
    set((state) => ({
      currentStrokes: {
        ...state.currentStrokes,
        [userId]: {
          strokeId,
          points: [point],
        },
      },
    })),

  // ==================================
  // add a point to the current stroke of a user
  // ==================================
  addPoint: ({ userId, point }) =>
    set((state) => {
      const existing = state.currentStrokes[userId];

      // SAFETY CHECK
      if (!existing) {
        return {}; // ignore invalid packet
      }

      return {
        currentStrokes: {
          ...state.currentStrokes,
          [userId]: {
            ...existing,
            points: [...existing.points, point],
          },
        },
      };
    }),

  // ==================================
  // end the stroke of a user and move it from currentStrokes to strokes array
  // ===================================
  endStroke: ({ userId, color, brushSize }) =>
    set((state) => {
      const current = state.currentStrokes[userId];

      if (!current) return {};

      const finishedStroke = {
        strokeId: current.strokeId,
        userId,
        color,
        brushSize,
        points: current.points,
      };

      const { [userId]: _, ...rest } = state.currentStrokes;

      return {
        strokes: [...state.strokes, finishedStroke],
        currentStrokes: rest,
      };
    }),

  // ==================================
  // undo the last stroke of a user
  //===================================
  undo: (strokeId) =>
    set((state) => {
      const strokeToRemove = state.strokes.find(
        (stroke) => stroke.strokeId === strokeId,
      );

      if (!strokeToRemove) return {};

      return {
        strokes: state.strokes.filter((stroke) => stroke.strokeId !== strokeId),
        redoStack: [...state.redoStack, strokeToRemove],
      };
    }),


  // ==================================
  // redo the last undo stroke of a user
  // ==================================
  redo: (userId) =>
    set((state) => {
      // find last undone stroke of this user
      const reversed = [...state.redoStack].reverse();
      const strokeToRestore = reversed.find(
        (stroke) => stroke.userId === userId,
      );

      if (!strokeToRestore) return {};

      return {
        strokes: [...state.strokes, strokeToRestore],
        redoStack: state.redoStack.filter(
          (stroke) => stroke.strokeId !== strokeToRestore.strokeId,
        ),
      };
    }),

  // ==================================
  // clear all strokes from the canvas
  // ==================================
  clear: () =>
    set({
      strokes: [],
      currentStrokes: {},
    }),
}));








import { io } from "socket.io-client";


export const socket = io("http://localhost:5000", {
  auth: {
    token: localStorage.getItem("token"),
  },
});










++++++++++++++++++++ backend ++++++++++++++++++++++
import express from "express";
import http from "http";
import { Server } from "socket.io";
import dotenv from "dotenv";
import { connectDB } from "./src/config/db.js";     
import canvasSocket from "./src/socket/CanvasSocket.js";
import userRoutes from "./src/routes/UserRoutes.js";
import { globalErrorHandler } from "./src/middleware/GlobalError.js";
import roomRoutes from "./src/routes/RoomRoutes.js";
import { ApiError } from "./src/utils/ApiError.js";
import User from "./src/models/User.js";
import jwt from "jsonwebtoken";

dotenv.config();
await connectDB();

const app = express();
const server = http.createServer(app);


// ---------------------------
// Socket.io setup with JWT authentication
// ---------------------------
const io = new Server(server, {
  cors: { origin: "*" },
});

io.use(async (socket, next) => {
  try {
    const token = socket.handshake.auth.token;

    if (!token) throw new ApiError(401, "No token provided");

    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    const user = await User.findById(decoded.id).select("-password");
    if (!user) throw new ApiError(401, "User not found");

    socket.user = user;

    next();
  } catch (err) {
    next(err || new ApiError(401, "Not authorized"));
  }
});

canvasSocket(io);

app.use(express.json());

// ---------------------------
// Routes
// ---------------------------
app.use("/api/auth", userRoutes);
app.use("/api/rooms", roomRoutes);

// ---------------------------
// Route not found Handler
// ---------------------------
app.use((req, res, next) => {
  next(new ApiError(404, "Route not found"));
});

app.use(globalErrorHandler);

server.listen(process.env.PORT || 5000, () =>
  console.log("Server running on port", process.env.PORT || 5000),
);





import Room from "../models/Room.js";
import Stroke from "../models/Stroke.js";

export default function canvasSocket(io) {
  io.on("connection", (socket) => {
    console.log("User connected:", socket.id);

    // ---------------------------
    // Join Room + Send History
    // ---------------------------
    socket.on("joinRoom", async ({ roomId }) => {
      try {
        const room = await Room.findById(roomId);

        if (!room) {
          return socket.emit("error", "Room not found");
        }

        const userId = socket.user._id;

        // Check if already member
        const isMember = room.members.some(
          (member) => member.toString() === userId.toString(),
        );

        // Add member if not already in room
        if (!isMember) {
          room.members.push(userId);
          await room.save();
        }

        socket.join(roomId);

        // Notify others
        socket.to(roomId).emit("userJoined", {
          userId,
          username: socket.user.username,
        });

        // Send history
        const strokes = await Stroke.find({
          roomId,
          isDeleted: false,
        });

        socket.emit("roomHistory", strokes);
      } catch (err) {
        socket.emit("error", "Something went wrong");
      }
    });

    // ---------------------------
    // Leave Room
    // ---------------------------
    socket.on("leaveRoom", async (roomId) => {
      const userId = socket.user._id;
      const room = await Room.findById(roomId);

      if (!room) {
        return socket.emit("error", "Room not found");
      }
      // Remove member
      room.members = room.members.filter(
        (member) => member.toString() !== userId.toString(),
      );
      await room.save();

      socket.leave(roomId);

      socket.to(roomId).emit("userLeft", {
        userId: socket.user._id,
        username: socket.user.username,
      });
    });

    // ---------------------------
    // Stroke Start (Emit to others in room)
    // ---------------------------
    socket.on("strokeStart", ({ roomId, point, strokeId }) => {
      // Emit to others in room
      socket
        .to(roomId)
        .emit("strokeStart", { userId: socket.user._id, strokeId, point });
    });

    //----------------------------
    // Stroke Point (Emit to others in room)
    //----------------------------
    socket.on(
      "strokePoint",
      ({ roomId, point, strokeId, color, brushSize }) => {
        socket.to(roomId).emit("strokePoint", {
          userId: socket.user._id,
          strokeId,
          point,
          color,
          brushSize,
        });
      },
    );

    //----------------------------
    // Stroke End (Save to DB and Emit to others in room)
    //----------------------------
    socket.on(
      "strokeEnd",
      async ({ roomId, points, strokeId, color, brushSize }) => {
        const newStroke = await Stroke.create({
          strokeId, // frontend strokeId
          roomId,
          userId: socket.user._id,
          points,
          color,
          width: brushSize,
        });

        // Emit strokeComplete with DB _id + strokeId
        io.to(roomId).emit("strokeComplete", {
          ...newStroke.toObject(),
          strokeId: newStroke.strokeId, // keep frontend strokeId
        });
      },
    );

    // ---------------------------
    // Undo (Soft Delete)
    // ---------------------------
    socket.on("undo", async ({ roomId, strokeId }) => {
      try {
        const stroke = await Stroke.findOne({
          strokeId,
          userId: socket.user._id,
        });
        if (!stroke)
          return socket.emit("error", "Stroke not found or not yours");

        stroke.isDeleted = true;
        await stroke.save();

        io.to(roomId).emit("undo", { strokeId });
      } catch (err) {
        socket.emit("error", "Unable to undo stroke");
      }
    });

    // ---------------------------
    // Redo (Restore Last Deleted Stroke of User)
    // ---------------------------
    socket.on("redo", async ({ roomId }) => {
      try {
        const lastDeleted = await Stroke.findOne({
          roomId,
          userId: socket.user._id,
          isDeleted: true,
        }).sort({ updatedAt: -1 });

        if (!lastDeleted) return socket.emit("error", "No stroke to redo");

        lastDeleted.isDeleted = false;
        await lastDeleted.save();

        io.to(roomId).emit("strokeComplete", {
          ...lastDeleted.toObject(),
          strokeId: lastDeleted.strokeId,
        });
      } catch (err) {
        socket.emit("error", "Unable to redo stroke");
      }
    });

    // ---------------------------
    // Clear (Soft Delete All)
    // ---------------------------
    socket.on("clear", async ({ roomId }) => {
      try {
        await Stroke.updateMany({ roomId }, { isDeleted: true });
        io.to(roomId).emit("clear");
      } catch (err) {
        socket.emit("error", "Unable to clear strokes");
      }
    });
    // ---------------------------
    // Disconnect
    // ---------------------------
    socket.on("disconnect", () => {
      console.log("User disconnected:", socket.id);
    });
  });
}






is k ilawa user register, login, token verify, room create all with joi validation and global ApiError and SendResponse k thorugh


ab baki kam krna h all room get, frontend ko refactor backend k hisab se